// This package implemetns Logger with colored output in console.
// Auto-generation of the filename for rotation.
// After overflow current log file auto create new file with timestamp.
package log

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"sync"
	"time"

	"github.com/fatih/color"
)

const (
	info       = "info"
	warn       = "warn"
	test       = "test"
	err        = "error"
	debug      = "debug"
	fileType   = "file"
	loggerType = "logger"
	formatTime = "20060102-150405"
)

var (
	_ io.WriteCloser = (*Logger)(nil)
	// Default log file size.
	defaultBytes int64 = 5 * 1024 * 1024
)

type Logger struct {
	Filename string     // path storage.
	Size     int64      // max size file (bytes).
	base     string     // base filename for rotation.
	mu       sync.Mutex // for concurrency write.
	file     *os.File   // current log file.
}

// Initialization new Logger.
// If direct or filename not created, go to create
// Usage example
// size := 50 *1024*1024 // 50mb
// logger:=NewLog("log/io.log",size)
// defer logger.Close()
func NewLog(filename string, size int64) *Logger {
	filename, base := setFilename(filename)
	size = setSize(size)

	// Check dir.
	// Dir is nil go to create
	// Dir is not nil go to skip.
	if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil {
		log.Fatalf("can't create log dir: %v", err)
	}

	f := createFile(filename)

	return &Logger{
		Filename: filename,
		base:     base,
		Size:     size,
		file:     f,
	}
}

// Info writes an information message to the log.
func (l *Logger) Info(msg string, args ...any) {
	l.log(info, msg, args...)
}

// Warn writes a warning to the log.
func (l *Logger) Warn(msg string, args ...any) {
	l.log(warn, msg, args...)
}

// Error writes an error to the log.
func (l *Logger) Error(msg string, args ...any) {
	l.log(err, msg, args...)
}

// Test writes test messages to the log.
func (l *Logger) Test(msg string, args ...any) {
	l.log(test, msg, args...)
}

// Debug writes debugging messages to the log.
func (l *Logger) Debug(msg string, args ...any) {
	l.log(debug, msg, args...)
}

// Write implements io.Writer.
// All entries go through rotation.
func (l *Logger) Write(p []byte) (n int, err error) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.fileLimit()
	n, err = l.file.Write(p)
	return n, err
}

// Close closes the log file. Defer after NewLog() is recommended.
func (l *Logger) Close() error {
	return l.file.Close()
}

// log is an internal logging function. First it writes to a file, then outputs it to the console.
func (l *Logger) log(logType, msg string, args ...any) {
	resFile := format(logType, fileType, msg, args...)
	_, err := l.Write([]byte(resFile))
	if err != nil {
		return
	}
	resLog := format(logType, loggerType, msg, args...)
	writeToConsole(resLog)
}

// fileLimit checks the file size and initiates rotation if necessary.
func (l *Logger) fileLimit() {
	fileInfo, err := os.Stat(l.Filename)
	if err != nil {
		log.Fatalf("file not open")
	}
	size := fileInfo.Size()

	if size >= l.Size {
		_ = l.file.Close()
		l.rotation()
		l.file = createFile(l.Filename)
	}
}

// rotation creates a new file name for time rotation.
// Changes l.Filename to a new path.
func (l *Logger) rotation() {
	baseDir := filepath.Dir(l.Filename)
	baseName := filepath.Base(l.base)
	ext := filepath.Ext(l.Filename)
	nameOnly := baseName[:len(baseName)-len(ext)]
	newName := fmt.Sprintf("%s-%s%s", nameOnly, time.Now().UTC().Format(formatTime), ext)
	l.Filename = filepath.Join(baseDir, newName)
}

// setFilename processes the input path and returns the full path to the log file + the base name for rotation.
// If the path is a directory or empty, adds the autogenerated file name.
func setFilename(filename string) (string, string) {
	if filename == "" {
		return filepath.Join("log", defaultLogFilename()), "spond.log"
	}
	if len(filename) > 0 && (filename[len(filename)-1] == '/' || filename[len(filename)-1] == '\\') {
		return filepath.Join(filename, defaultLogFilename()), "spond.log"
	}
	if stat, err := os.Stat(filename); err == nil && stat.IsDir() {
		return filepath.Join(filename, defaultLogFilename()), "spond.log"
	}
	return filename, filepath.Base(filename)
}

// defaultLogFilename returns the default file name (with timestamp).
func defaultLogFilename() string {
	return time.Now().UTC().Format("20060102-150405") + "-" + "spond" + ".log"
}

// setSize returns the correct file size. If <= 0, it is default.
func setSize(size int64) int64 {
	if size <= 0 {
		return defaultBytes
	}
	return size
}

// createFile opens the file for writing (or creates it if there is none).
func createFile(filename string) *os.File {
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("can't open log file: %v", err)
	}
	return f
}

// colored returns a color string for console output by log type.
func colored(logType string) string {
	switch logType {
	case info:
		return color.New(color.FgGreen, color.Bold).Sprint(logType)
	case warn, test:
		return color.New(color.FgYellow, color.Bold).Sprint(logType)
	case err:
		return color.New(color.FgRed, color.Bold).Sprint(logType)
	case debug:
		return color.New(color.FgCyan, color.Bold).Sprint(logType)
	default:
		return logType
	}
}

// writeToConsole writes the log to Stdout.
func writeToConsole(msg string) {
	os.Stdout.WriteString(msg)
}

// format â€” formats the log string for the file or console.
func format(logType, formatType, msg string, args ...any) string {
	currentTime := time.Now().UTC().Format(formatTime)
	notification := fmt.Sprintf(msg, args...)
	switch formatType {
	case fileType:
		return fmt.Sprintf("%s [%s] %s\n", currentTime, logType, notification)
	case loggerType:
		return fmt.Sprintf("%s [%s] %s\n", currentTime, colored(logType), notification)
	default:
		return fmt.Sprintf("%s [error] formatType is invalid\n", currentTime)
	}

}
